from pathlib import Path

import pandas as pd
from loguru import logger


def stop_words():
    """
    Read a file of stop words, or reported technical functions that should be excluded
    from curation efforts.

    Stop words were generated by manually reviewing unique reported technical functions
    across all three valid sectors. If a function mentioned confidential, non-tsca use
    (with no additional use information), other use (with no additional use information),
    unknown, or 'not known or reasonably ascertainable' then it was added to the stop
    word file. If a function was only a number or single character it was also added to
    the file.
    """
    with open("stop_fcs.txt", "r") as f:
        stops = f.read().splitlines()
    return stops


def cdr_use_retrieval(sector: str, dpath: Path):
    """
    Function to retrieve all technical function data from an CDR 2020 Public Excel Data
    File that was published on EPA's public website:
    https://www.epa.gov/chemical-data-reporting/access-chemical-data-reporting-data#2020

    Parameters
    ----------
    sector: str
        Sector of economy from which use information is obtains. Options are
        "Industrial", "Consumer" (for Consumer and Commercial sectors), or
        "Manufacturing" (for Manufacturing and Import sectors)

    dpath: pathlib.Path
        File path to CDR 2020 Public Excel Data files

    save: bool (default False)
        whether to

    Returns
    -------
    pd.DataFrame
        DataFrame object that contains unique, non-null (chemical_name, chemical_id,
        chemical_id_type, function_category) records from the appropriate economic
        sector of published CDR information.
    """

    # Data dictionary containing, for each sector:
    #     - the name of the file (searched for via glob/wildcard)
    #     - the columns that contain functional use information in that file
    opts = {
        "Industrial": {
            "file": list(dpath.glob("*Industrial*"))[0],
            "columns": [
                "chemical_name",
                "chemical_id",
                "chemical_id_type",
                "industrial_function_category",
                "ind_funct_cat_other_desc",
                "joint_function_category",
                "joint_funct_cat_other_desc",
            ],
        },
        "Consumer": {
            "file": list(dpath.glob("*Consumer*"))[0],
            "columns": [
                "chemical_name",
                "chemical_id",
                "chemical_id_type",
                "cons_or_comm_function_category",
                "cons_or_comm_funct_cat_other_desc",
                "joint_function_category",
                "joint_funct_cat_other_desc",
            ],
        },
        "Manufacturing": {
            "file": list(dpath.glob("*Manufacturing*"))[0],
            "columns": [
                "chemical_name",
                "chemical_id",
                "chemical_id_type",
                "joint_function_category",
                "joint_funct_cat_other_desc",
            ],
        },
    }

    # Check that the sector supplied is a valid one
    sector = sector.title()
    if sector not in opts.keys():
        raise KeyError(f"Sector {sector}, not a valid sector of CDR.")

    # Check that the file extension is read by the correct Pandas read option
    ifile = opts[sector]["file"]
    if ifile.suffix == ".parq":
        df = pd.read_parquet(ifile)
    elif ifile.suffix == ".xlsx":
        df = pd.read_excel(ifile)
    else:
        raise ValueError(f"No option to read {ifile} CDR file.")

    # Canonicalize column names
    df.rename(
        lambda x: (
            x.lower()
            .replace(" ", "_")
            .replace("c_/_c", "cons_or_comm")
            .replace("consumer_/_commercial", "cons_or_comm")
            .replace("cons_/_comm", "cons_or_comm")
        ),
        axis=1,
        inplace=True,
    )

    # Keep only the needed columns
    df = df[opts[sector]["columns"]].copy()

    # Convert from wide to long format
    df = pd.melt(
        frame=df,
        id_vars=["chemical_name", "chemical_id", "chemical_id_type"],
        var_name="function_category_type",
        value_name="function_category",
    ).drop(["function_category_type"], axis=1)

    # Drop records with no reported function
    df = df[df.function_category.notnull()].copy()

    # Remove functions that are stop words
    df = df[~df.function_category.isin(stop_words())].copy()

    # Drop duplicated records
    df.drop_duplicates(inplace=True)

    return df.copy()


def write_chemical_use_file(sector: str, opath: Path, df: pd.DataFrame):
    """
    Writes a single chemical and all its reported technical functions to a file

    Parameters
    ----------
    sector: str
        Sector of economy from which use information is obtains. Options are
        "Industrial", "Consumer" (for Consumer and Commercial sectors), or
        "Manufacturing" (for Manufacturing and Import sectors)

    opath: pathlib.Path
        File path that chemical use file is saved to

    df: pd.DataFrame
        DataFrame object of a single chemical (name and identifiers) and all reported
        technical functions

    Returns
    -------
    None
    """

    # Store names to use with chemical use files
    opts = {
        "industrial": "industrial",
        "consumer": "consumer_and_commercial",
        "manufacturing": "manufacturing_and_import",
    }

    ofile = opath / f"cdr_2020_{opts[sector]}_uses_{df['chemical_id'].unique()[0]}.xlsx"

    if not ofile.is_file():
        # Dump DataFrame to file
        (df.to_excel(ofile, index=False))
    else:
        logger.info(f"{ofile.name} already written, skipping re-write.")
    return


# Path to Publicly Released Data
dpath = Path("2020 CDR Public Parquet Data/")

# Valid economic sectors
sectors = ["industrial", "consumer", "manufacturing"]


for sector in sectors:
    # Write progress to screen
    logger.info(f"Now writing {sector} files.")

    # Path to generated output files
    opath = Path(f"factotum_upload/{sector}")

    # Get the data in the right form
    data = (
        cdr_use_retrieval(sector=sector, dpath=dpath)
        .set_index(keys=["chemical_name", "chemical_id", "chemical_id_type"])
        .sort_index()
    )

    # Get the unique chemical records
    idxs = data.index.drop_duplicates().tolist()

    # Loop over the chemicals and write their uses to a file
    for i, idx in enumerate(idxs[::-1]):
        df = data.loc[idx, :].reset_index().copy()
        write_chemical_use_file(sector=sector, opath=opath, df=df)
